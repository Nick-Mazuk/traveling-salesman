!function(e){var t={};function i(n){if(t[n])return t[n].exports;var s=t[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(n,s,function(t){return e[t]}.bind(null,s));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=0)}([function(e,t,i){"use strict";function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function s(e,t){var i=t.get(e);if(!i)throw new TypeError("attempted to get private field on non-instance");return i.get?i.get.call(e):i.value}i.r(t);class o{constructor(e,t){n(this,"cityA",void 0),n(this,"cityB",void 0),r.set(this,{writable:!0,value:"#757575"}),a.set(this,{writable:!0,value:"#FCCE00"}),this.cityA=e,this.cityB=t}draw(e,t,i){if(t){if(e.beginPath(),e.moveTo(this.cityA.anchorX,this.cityA.anchorY),this.cityA.onSameHorizontalRoad(this.cityB))e.lineTo(this.cityB.anchorX,this.cityB.anchorY);else if(this.cityA.blockColumn==this.cityB.blockColumn){if(this.cityA.blockColumnPosition>0&&this.cityB.blockColumnPosition>0){const t=3-this.cityA.blockColumnPosition;e.lineTo(this.cityA.anchorX+t*i,this.cityA.anchorY),e.lineTo(this.cityA.anchorX+t*i,this.cityB.anchorY)}else{const t=this.cityA.blockColumnPosition+1;e.lineTo(this.cityA.anchorX-t*i,this.cityA.anchorY),e.lineTo(this.cityA.anchorX-t*i,this.cityB.anchorY)}e.lineTo(this.cityB.anchorX,this.cityB.anchorY)}else{if(this.cityA.anchorX<this.cityB.anchorX){const t=3-this.cityA.blockColumnPosition;e.lineTo(this.cityA.anchorX+t*i,this.cityA.anchorY),e.lineTo(this.cityA.anchorX+t*i,this.cityB.anchorY)}else{const t=this.cityA.blockColumnPosition+1;e.lineTo(this.cityA.anchorX-t*i,this.cityA.anchorY),e.lineTo(this.cityA.anchorX-t*i,this.cityB.anchorY)}e.lineTo(this.cityB.anchorX,this.cityB.anchorY)}e.strokeStyle=s(this,r),t&&(e.strokeStyle=s(this,a)),e.lineWidth=o.width,e.stroke()}else e.beginPath(),e.moveTo(this.cityA.xPos,this.cityA.yPos),e.lineTo(this.cityB.xPos,this.cityB.yPos),e.strokeStyle=s(this,r),t&&(e.strokeStyle=s(this,a)),e.lineWidth=o.width,e.stroke()}length(e){return this.cityA.distanceFromCity(this.cityB,e)}}var r=new WeakMap,a=new WeakMap;function h(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}n(o,"width",3);class l{constructor(e=[]){h(this,"cities",void 0),h(this,"roads",void 0),h(this,"totalLength",void 0),this.cities=e.slice(),this.roads=[]}length(e){let t=0;if(0==this.cities.length)return 0;for(let i=0;i<this.cities.length-1;i++)t+=this.cities[i].distanceFromCity(this.cities[i+1],e);return t+=this.cities[0].distanceFromCity(this.cities[this.cities.length-1],e),this.totalLength=t,t}_createRoads(){if(this.roads=[],this.cities.length>2){for(let e=0;e<this.cities.length-1;e++)this.roads.push(new o(this.cities[e],this.cities[e+1]));this.roads.push(new o(this.cities[this.cities.length-1],this.cities[0]))}else this.cities.length>1&&(this.roads.push(new o(this.cities[0],this.cities[1])),this.roads.push(new o(this.cities[1],this.cities[0])));return this.roads}addCity(e){this.cities.push(e)}draw(e,t,i,n,s){e.clearRect(0,0,e.canvas.clientWidth,e.canvas.clientHeight),t.length&&(e.beginPath(),e.rect(0,0,e.canvas.clientWidth,e.canvas.clientHeight),e.fillStyle="#171717",e.fill(),t.forEach(t=>t.draw(e,i,n))),this._createRoads(),this.roads.forEach(t=>t.draw(e,s,i)),this.cities.forEach(t=>t.draw(e,s,Math.min(i,n)))}positionInCity(e,t){return this.cities.filter(i=>i.pointIsInCity(e,t))}randomizeRoute(){this.cities=this.cities.sort(()=>Math.random()-.5)}getRandomCityIndex(e=0,t=this.cities.length){return(Math.ceil(Math.random()*Math.min(this.cities.length-1,t))+e)%this.cities.length}getCityByIndex(e){return this.cities[e]}getLengthChangeFromSwappingCities(e,t,i){if(e==t)return 0;if(e>t){let i=e;e=t,t=i}let n=0,s=this.cities[e],o=this.cities[t],r=this.cities[0==e?this.cities.length-1:e-1],a=this.cities[(t+1)%this.cities.length];return n+=s.distanceFromCity(r,i),n+=o.distanceFromCity(a,i),n-=s.distanceFromCity(a,i),n-=o.distanceFromCity(r,i),n<.001&&n>-.001&&(n=0),n}swapCitiesByIndex(e,t){if(e==t)return;if(e>t){let i=e;e=t,t=i}let i=this.cities.slice();this.cities=[...i.slice(0,e)],this.cities.push(...i.slice(e,t+1).reverse()),this.cities.push(...i.slice(t+1))}removeCity(e){this.cities=this.cities.filter(t=>t.xPos!=e.xPos||t.yPos!=e.yPos)}findNeighbors(e){if(0==this.cities.includes(e))throw new Error("City is not in tour, cannot find neighbors");if(this.cities.length<3)throw new Error("Tour does not have enough cities to find neighbors");let t=[],i=this.cities.indexOf(e);switch(i){case 0:t.push(this.cities[this.cities.length-1]),t.push(this.cities[1]);break;case this.cities.length-1:t.push(this.cities[i-1]),t.push(this.cities[0]);break;default:t.push(this.cities[i-1]),t.push(this.cities[i+1])}return t}cityNeighborsAreClosest(e,t){const i=this.findNeighbors(e),n=Math.max(...i.map(i=>e.distanceFromCity(i,t)));for(let s=0;s<this.cities.length;s++){if(i.includes(this.cities[s])||this.cities[s]==e)continue;if(e.distanceFromCity(this.cities[s],t)<=n)return!1}return!0}clear(){this.cities=[],this.roads=[],this.totalLength=void 0}static getPermutations(e){return(e=>{let t=[];const i=(e,n=[])=>{if(0===e.length)t.push(n);else for(let t=0;t<e.length;t++){let s=e.slice(),o=s.splice(t,1);i(s.slice(),n.concat(o))}};return i(e),t})(e.cities)}}class c{static optimize(e,t,i,n,s){if(e.cities.length<4)return e;switch(s||(e=c.bogo(e)),t){case"annealing":e=c.annealing(e,i,n,!!s);break;case"greedy":e=c.greedy(e,n);break;case"bogo":e=c.bogo(e);break;case"force":e=c.force(e,n);break;case"uncross":e=c.uncross(e,n,!!s);break;case"speedy":e=c.speedy(e,n,s);break;default:e=c.speedy(e,n,s)}return e}static annealing(e,t,i,n,s=150){function o(e,t,i){return i*(1-e/t)+1e-4}n||(e=c.greedy(e,i)),null!=t&&(s=(t.getBoundingClientRect().width+t.getBoundingClientRect().height)/18);let r=n?1.8:2.5,a=100*e.cities.length+(e.cities.length>10?(e.cities.length-10)**r:0),h=0,u=e.length(i),d=new l(e.cities),g=d,m=u;for(;h<a;){let e=o(h,a,s);const t=new l(g.cities),n=t.getRandomCityIndex();let r=t.getRandomCityIndex(n,e);const c=t.getLengthChangeFromSwappingCities(n,r,i),f=Math.random(),p=Math.exp(-Math.abs(c)/e);if(c>0||0!=c&&f<=p){t.swapCitiesByIndex(n,r),g=t;let e=t.length(i);m=e,e<u&&(u=e,d=t)}h++}return d}static greedy(e,t){if(e.cities.length<4)return e;for(let i=0;i<e.cities.length-1;i++){let n=i+1,s=1/0;for(let o=n;o<e.cities.length;o++){let r=e.cities[i].distanceFromCity(e.cities[o],t);r<s&&(n=o,s=r)}e.swapCitiesByIndex(i+1,n)}return e}static bogo(e){return e.randomizeRoute(),e}static force(e,t){if(e.cities.length>9)return alert("Brute force is slow. Very slow. It will likely take minutes if not much longer, so the algorithm was aborted. Please delete cities or choose another algorithm."),e;let i=e.length(t),n=new l(e.cities);return l.getPermutations(e).forEach(e=>{let s=new l(e);const o=s.length(t);o<i&&(i=o,n=s)}),n}static uncross(e,t,i){i||(e=c.greedy(e,t));let n,s=e.length(t);do{n=s;for(let i=0;i<e.cities.length;i++)for(let n=i+1;n<e.cities.length;n++){if(i==n)continue;const o=new l(e.cities);o.getLengthChangeFromSwappingCities(i,n,t)>0&&(o.swapCitiesByIndex(i,n),e=o,s=o.length(t))}}while(e.length(t).toFixed(2)!=n.toFixed(2));return e}static speedyAnnealing(e,t){function i(e,t,i){return i*(1-e/t)+1e-4}const n=3*e.cities.length,s=50*n;let o=0,r=e.length(),a=new l(e.cities),h=a,c=r;for(;o<s;){let e=i(o,s,n);const u=new l(h.cities),d=u.getRandomCityIndex();let g=u.getRandomCityIndex(d,e);const m=u.getLengthChangeFromSwappingCities(d,g,t),f=Math.random(),p=Math.exp(-Math.abs(m)/e);if(m>0||0!=m&&f<=p){u.swapCitiesByIndex(d,g),h=u;let e=u.length(t);c=e,e<r&&(r=e,a=u)}o++}return a}static speedy(e,t,i){if(null!=i){let n=e.cities.indexOf(i),s=!1;for(let i=0;i<e.cities.length;i++){if(i==n)continue;const o=new l(e.cities);if(o.getLengthChangeFromSwappingCities(i,n,t)>0){o.swapCitiesByIndex(i,n),e=o,s=!0;break}}return s?(e=c.speedyAnnealing(e,t),c.uncross(e,t)):e}return e=c.greedy(e,t),e=c.speedyAnnealing(e,t),e=c.uncross(e,t,!0)}}function u(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class d{constructor(e,t,i,n,s,o,r,a,h){u(this,"xPos",void 0),u(this,"yPos",void 0),u(this,"canvas",void 0),g.set(this,{writable:!0,value:"#757575"}),u(this,"selected",!1),u(this,"anchorX",void 0),u(this,"anchorY",void 0),u(this,"blockColumn",void 0),u(this,"blockColumnPosition",void 0),u(this,"blockXSize",void 0),u(this,"blockYSize",void 0),this.canvas=i,this.move(e,t,n,s,o,r,a,h)}draw(e,t,i){if(t){const t=.5*i,n=t/2,s=1.25*t,o=s/2;this.selected&&(e.globalAlpha=.5),e.drawImage(d.houseImage,this.xPos-o,this.yPos-n,s,t),this.selected&&(e.globalAlpha=1)}else e.beginPath(),e.arc(this.xPos,this.yPos,d.radius,0,2*Math.PI),e.fillStyle=function(e,t){var i=t.get(e);if(!i)throw new TypeError("attempted to get private field on non-instance");return i.get?i.get.call(e):i.value}(this,g),e.fill()}pointIsInCity(e,t){return this.distanceFromPoint(e,t)<d.radius}distanceFromPoint(e,t){return Math.sqrt((e-this.xPos)**2+(t-this.yPos)**2)}distanceFromCity(e,t){if(t){let t=Math.abs(this.anchorX-e.anchorX)+Math.abs(this.anchorY-e.anchorY);const i=this.blockColumn==e.blockColumn,n=this.onSameHorizontalRoad(e);return i&&!n&&(1==this.blockColumnPosition&&1==e.blockColumnPosition?t+=4*this.blockXSize:t+=2*this.blockXSize),t}return Math.sqrt((e.xPos-this.xPos)**2+(e.yPos-this.yPos)**2)}move(e,t,i,n,s,o,r,a){e<d.radius&&(e=d.radius),t<d.radius&&(t=d.radius),e>this.canvas.getBoundingClientRect().width-d.radius&&(e=this.canvas.getBoundingClientRect().width-d.radius),t>this.canvas.getBoundingClientRect().height-d.radius&&(t=this.canvas.getBoundingClientRect().height-d.radius),this.xPos=e,this.yPos=t,i&&(this.anchorX=i),n&&(this.anchorY=n),null!=s&&(this.blockColumn=s),null!=o&&(this.blockColumnPosition=o),r&&(this.blockXSize=r),a&&(this.blockYSize=a)}onSameHorizontalRoad(e){return Math.abs(this.anchorY-e.anchorY)<3}static isPointInBlock(e,t,i){const n=t.getImageData(e[0]*i,(e[1]+o.width)*i,1,1).data;if(23==n[0]&&23==n[1]&&23==n[2])return!1;const s=t.getImageData(e[0]*i,(e[1]-o.width)*i,1,1).data;if(23==s[0]&&23==s[1]&&23==s[2])return!1;const r=t.getImageData((e[0]-o.width)*i,e[1]*i,1,1).data;if(23==r[0]&&23==r[1]&&23==r[2])return!1;const a=t.getImageData((e[0]+o.width)*i,e[1]*i,1,1).data;return 23!=a[0]||23!=a[1]||23!=a[2]}}var g=new WeakMap;function m(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}u(d,"radius",10),u(d,"houseImage",new Image);class f{constructor(e,t,i,n){m(this,"xPos",void 0),m(this,"yPos",void 0),m(this,"width",void 0),m(this,"height",void 0),p.set(this,{writable:!0,value:"#007A00"}),this.xPos=e,this.yPos=t,this.width=i,this.height=n}draw(e,t,i){let n=t/4;e.beginPath(),e.moveTo(this.xPos*t+n,this.yPos*i),e.lineTo((this.xPos+this.width)*t-n,this.yPos*i),e.quadraticCurveTo((this.xPos+this.width)*t,this.yPos*i,(this.xPos+this.width)*t,this.yPos*i+n),e.lineTo((this.xPos+this.width)*t,(this.yPos+this.height)*i-n),e.quadraticCurveTo((this.xPos+this.width)*t,(this.yPos+this.height)*i,(this.xPos+this.width)*t-n,(this.yPos+this.height)*i),e.lineTo(this.xPos*t+n,(this.yPos+this.height)*i),e.quadraticCurveTo(this.xPos*t,(this.yPos+this.height)*i,this.xPos*t,(this.yPos+this.height)*i-n),e.lineTo(this.xPos*t,this.yPos*i+n),e.quadraticCurveTo(this.xPos*t,this.yPos*i,this.xPos*t+n,this.yPos*i),e.fillStyle=function(e,t){var i=t.get(e);if(!i)throw new TypeError("attempted to get private field on non-instance");return i.get?i.get.call(e):i.value}(this,p),e.fill()}}var p=new WeakMap;function y(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class v{constructor(){y(this,"modalElement",void 0),y(this,"closeButton",void 0),y(this,"skipButton",void 0),y(this,"previousButton",void 0),y(this,"nextButton",void 0),y(this,"finishButton",void 0),y(this,"replayTutorialElement",void 0),y(this,"bodyContent",void 0),y(this,"contentImage",void 0),y(this,"currentPanel",0),y(this,"panels",["<h2>What is the traveling salesman problem?</h2>\n        <p>How can Amazon deliver toilet paper in 2 days? This isn't a simple problem. At the very last stretch, Amazon loads your toilet paper into a van. But that van has dozens of other deliveries. So Amazon needs to <b>find the shortest route between every house</b>. Finding that shortest route is the traveling salesman problem.</p>","<h2>Add, move, or remove houses…</h2>\n        <ul>\n            <li><b>Add houses</b>: Click somewhere empty to add a house</li>\n            <li><b>Move houses</b>: Click and drag to move it around</li>\n            <li><b>Remove houses</b>: Just click a house and it's gone</li>\n        </ul>","<h2>…and the route updates in real-time!</h2>\n        <p>Unlike most traveling salesman visualizers, this one updates in real-time. Explore how <b>minor movements can cause massive changes</b>.</p>","<h2>Choose your algorithm wisely…</h2>\n        <p>Select an algorithm from the dropdown menu.</p>\n        <ul>\n            <li><b>Brute Force</b>: Checks every possible path, guarantees shortest path</li>\n            <li><b>Greedy</b>: Each house connects with the next closest house</li>\n            <li><b>Annealing</b>: Gradually improves through random changes, avoids local mins</li>\n            <li><b>2-opt</b>: Chooses random path, then uncrosses intersections</li>\n            <li><b>Speedy</b>: Custom algorithm, combines greedy, annealing, and 2-opt</li>\n            <li><b>BOGO</b>: Chooses random path, odds of finding shortest path is 1:(n - 1)!</li>\n        </ul>","<h2>…because some are just better than others.</h2>\n        <p>Some take way too long to finish. Others find paths that are way too long. Choose wisely or you'll have to wait until the heat death of the universe for an answer.</p>","<h2>Choose your own reality.</h2>\n        <p>Find the shortest route through some bustling suburbs, or test the limits of the algorithms on a lifeless, theoretical void. The choice is yours!</p>","<h2>Explore this simulation in depth</h2>\n        <p>Learn the specifics behind each algorithm.</p>\n        <p>Check out the code on <a href='https://github.com/Nick-Mazuk/traveling-salesman' target='_blank'>Github</a> (and star the repo).</p>\n        <p>Now start exploring! Ready, set, go…</p>"]),y(this,"panelImages",["./assets/logo/Logo.svg","./assets/addHouses.gif","./assets/updateRealTime.gif","./assets/chooseAlgorithm.gif","./assets/algorithmComparison.gif","./assets/cityGrid.gif","./assets/more.gif"]),this.getHTMLElements(),this.addEventListeners(),this.displayPanel()}getHTMLElements(){this.modalElement=document.querySelector("#tutorial-modal"),this.closeButton=document.querySelector("#tutorial-close"),this.skipButton=document.querySelector("#tutorial-skip"),this.previousButton=document.querySelector("#tutorial-previous"),this.nextButton=document.querySelector("#tutorial-next"),this.finishButton=document.querySelector("#tutorial-finish"),this.bodyContent=document.querySelector("#tutorial-content"),this.contentImage=document.querySelector("#tutorial-image"),this.replayTutorialElement=document.querySelector("#tutorial-replay")}addEventListeners(){this.closeButton.addEventListener("click",()=>this.closeModal()),this.skipButton.addEventListener("click",()=>this.closeModal()),this.previousButton.addEventListener("click",()=>this.previousPanel()),this.nextButton.addEventListener("click",()=>this.nextPanel()),this.finishButton.addEventListener("click",()=>this.closeModal()),this.replayTutorialElement.addEventListener("click",()=>this.replayTutorial())}openModal(){this.modalElement.classList.add("is-active")}closeModal(){this.modalElement.classList.remove("is-active")}ifLastPanel(){this.currentPanel==this.panels.length-1?(this.nextButton.classList.add("is-hidden"),this.finishButton.classList.remove("is-hidden")):(this.nextButton.classList.remove("is-hidden"),this.finishButton.classList.add("is-hidden"))}ifFirstPanel(){0==this.currentPanel?this.previousButton.classList.add("is-hidden"):this.previousButton.classList.remove("is-hidden")}updateButtons(){this.ifFirstPanel(),this.ifLastPanel()}nextPanel(){this.currentPanel++,this.displayPanel()}previousPanel(){this.currentPanel--,this.displayPanel()}preloadImage(){this.panelImages[this.currentPanel+1]&&(this.bodyContent.innerHTML+=`<link rel="preload" href="${this.panelImages[this.currentPanel+1]}" as="image">`)}displayPanel(){this.bodyContent.innerHTML=this.panels[this.currentPanel],this.contentImage.src=this.panelImages[this.currentPanel],this.updateButtons(),this.preloadImage()}replayTutorial(){this.currentPanel=0,this.displayPanel(),this.openModal()}}function b(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class w{constructor(){b(this,"modalElement",void 0),b(this,"closeButton",void 0),b(this,"learnAlgorithmsElement",void 0),b(this,"tabs",void 0),b(this,"algorithmOverview",void 0),b(this,"algorithmSpecifics",void 0),b(this,"algorithmFeatures",void 0),b(this,"algorithms",{force:{overview:"Checks every possible path, guarantees shortest path.",specifics:"<p>Loop through every possible route. If the current route is shorter than all routes already checked, then set it as the shortest route. Return the shortest route at the end.</p>\n            \n            <code class='multi-line'>function bruteForce(route) {\n    let shortestLength = route.length();\n    let shortestRoute = new Route(route.houses); // clones route\n    const permutations = Route.getPermutations(route);\n    permutations.forEach(order => {\n        let currentRoute = new Route(order);\n        const length = currentRoute.length();\n        if (length < shortestLength) {\n            shortestLength = length;\n            shortestRoute = currentRoute;\n        }\n    })\n    return shortestRoute;\n}</code>",features:"<ul>\n            <li>Very slow: <code>O(n!)</code></li>\n            </ul>"},greedy:{overview:"Each house connects with the next closest house.",specifics:"<p>Loop through each house. Then, find the closes house that hasn't already been picked.</p>\n            \n            <code class='multi-line'>function greedy(route) {\n    for (let i = 0; i < route.houses.length - 1; i++) {\n        let closestHouse = i + 1;\n        let closestDistance = Infinity;\n        for (let j = closestHouse; j < route.houses.length; j++) {\n            let distance = route.houses[i].distanceFromHouse(route.houses[j]);\n            if (distance < closestDistance) {\n                closestHouse = j;\n                closestDistance = distance;\n            }\n        }\n        route.swapHousesByIndex(i + 1, closestHouse);\n    }\n    return route;\n}</code>",features:"<ul>\n            <li>Very fast (comparatively): <code>O(n^2)</code></li>\n            <li>Guaranteed to produce not-worst case</li>\n            <li>Guaranteed to produce not-best case, either</li>\n            </ul>"},annealing:{overview:"Gradually improves through random changes, avoids local mins.",specifics:"\n<p>Repeatedly make changes to the route. As time goes on, make smaller and smaller changes. After each change, check if the new route is shorter than the previous. If so, set it as the new shortest.</p>\n\n<p>Also, every now and then, it's okay to pick worse route than your current shortest. That way, you can avoid local mins.</p>\n\n<p>As time goes on, make the variations smaller and lower your tolerance for worse routes.</p>\n\n<p><i>Simplified code:</i></p>\n            <code class='multi-line'>function annealing (route) {\n    function calcTemp(frame, maxTime, maxTemp) {\n        return maxTemp * (1 - frame / maxTime) + 0.0001;\n    }\n\n    const maxTemp = CONSTANT;\n    const maxTime = VARIABLE; // depends on # of houses, ~O(n^2)\n    let frame = 0;\n    let shortestLength = route.length();\n    let shortest = new Route(route.houses);\n\n    let lastRoute = shortest;\n    let lastLength = shortestLength;\n\n    while (frame < maxTime) {\n        let temp = calcTemp(frame, maxTime, maxTemp);\n        const route = new Route(lastRoute.houses);\n\n        const houseA = route.getRandomHouseIndex();\n        const houseB = route.getRandomHouseIndex();\n\n        const change = route.diffFromSwappingHouses(houseA, houseB);\n        const random = Math.random();\n        const prob = Math.exp(-Math.abs(change) / temp); // probability function for determining \"acceptable worseness\"\n        if (change > 0 || (change != 0 && random <= prob)) {\n            route.swapHousesByIndex(houseA, houseB); // O(n) worst case for this specific swap function\n            lastRoute = route;\n            let newLength = route.length();\n            lastLength = newLength;\n            if (newLength < shortestLength) {\n                shortestLength = newLength;\n                shortest = route;\n            }\n        }\n\n\n        frame++;\n    }\n    return shortest;\n\n}</code>",features:"<ul>\n            <li>Not slow, but not extremely fast: <code>O(~n^3)</code></li>\n            <li>Because worse routes are occasionally accepted, this algorithm avoids local minimums</li>\n            <li>Very similar to a hill-climbing algorithm</li>\n            </ul>"},uncross:{overview:"Chooses random path, then uncrosses intersections.",specifics:"<p>Picks two random roads between houses. If those roads are crossing, uncross them. This will always shorten the path. Continue looping over all roads until all routes are uncrossed.</p>\n            <code class='multi-line'>function uncross(route) {\n    let shortestOverallLength = route.length();\n    let previousRoundLength;\n    do {\n        previousRoundLength = shortestOverallLength;\n        for (let i = 0; i < route.houses.length; i++) {\n            for (let j = i + 1; j < route.houses.length; j++) {\n                const currentRoute = new Route(route.houses);\n                const crossed = currentRoute.areHousesCrossed(i, j);\n                if (crossed) {\n                    currentRoute.swapHousesByIndex(i, j);\n                    route = currentRoute;\n                    shortestOverallLength = currentRoute.length();\n                }\n            }\n        }\n    } while (route.length != previousRoundLength)\n    return route;\n}</code>\n            ",features:"<ul>\n            <li>Very fast: <code>O(n^2)</code></li>\n            <li>Because uncrossing roads always makes the route shorter, it is very good at eliminating inefficiencies other algorithms won't easily find.</li>\n            <li>Very good, gets close to ideal route, but susceptible to local mins</li>\n            </ul>"},speedy:{overview:"Custom algorithm, combines greedy, annealing, and 2-opt.",specifics:"<ul>\n            <li><b>Greedy</b> is very good at getting not-worst path fast</li>\n            <li><b>Annealing</b> is very good at avoiding local mins</li>\n            <li><b>2-Opt</b> is very good at removing small inefficiencies</li>\n            </ul>\n            \n            <p>So this algorithm combines all of them in that order to take advantage of each algorithm's strengths while avoiding their weaknesses.</p>\n            \n            <p>For instance, because the Annealing algorithm doesn't need to find the best solution (only avoid local min), you can loop through it fewer times, resulting in a far lower time complexity.</p>\n\n            <p>Furthermore, when you are moving a house, Speedy first looks to see if swapping any house with the one you're moving makes a shorter route. It will only run fully if there's a shorter route.</p>\n\n            <code class='multi-line'>function speedy(route, movedHouse) {\n    if (movedHouse) {\n        let houseIndex = route.houses.indexOf(movedHouse);\n        let swappedHouses = false;\n\n        for (let i = 0; i < route.houses.length; i++) {\n            if (i == houseIndex) continue;\n            const currentRoute = new Route(route.houses);\n            const change = currentRoute.diffFromSwappingHouses(i, houseIndex);\n            if (change > 0) {\n                currentRoute.swapHousesByIndex(i);\n                route = currentRoute;\n                swappedHouses = true;\n                break;\n            }\n        }\n        if (swappedHouses) {\n            // since house movements are continuous, no need to run greedy\n            route = annealing(route); // faster version\n            return uncross(route); // 2-opt\n        }\n        return route;\n    }\n    // if running from the start\n    route = greedy(route);\n    route = annealing(route); // faster version\n    route = uncross(route); // 2-opt\n    return route;\n}</code>",features:"<ul>\n            <li>Very fast:\n                <ul>\n                <li>Best case: <code>O(n)</code></li>\n                <li>Worst case: <code>O(n^2)</code></li>\n                </ul>\n            </li>\n            <li>When moving a house, no other standard algorithm is faster</li>\n            <li>On average, it produces results slightly better than annealing and 2-opt</li>\n            <li>On average, it is faster than annealing, though slower in real-time speed than 2-opt</li>\n            </ul>"},bogo:{overview:"Chooses random path, odds of finding shortest path is <code>1:(n - 1)!</code>",specifics:"<p>Simply randomize the route.</p>\n            <code class='multi-line'>function bogo(route) {\n    return route.houses.sort(() => Math.random() - 0.5);\n}</code>",features:"<ul>\n            <li>Very fast: <code>O(n log(n))</code></li>\n            <li>If you ever get a decent route with many houses, buy a lottery ticket</li>\n            <li>Looks neat when moving houses around!</li>\n            </ul>"}}),this.getHTMLElements(),this.addEventListeners()}getHTMLElements(){this.modalElement=document.querySelector("#algorithms-modal"),this.closeButton=document.querySelector("#algorithms-modal-close"),this.learnAlgorithmsElement=document.querySelector("#learn-algorithms"),this.algorithmOverview=document.querySelector("#algorithm-overview"),this.algorithmSpecifics=document.querySelector("#algorithm-specifics"),this.algorithmFeatures=document.querySelector("#algorithm-features"),this.tabs=document.querySelectorAll(".algorithms-tab")}addEventListeners(){this.closeButton.addEventListener("click",()=>this.closeModal()),this.learnAlgorithmsElement.addEventListener("click",()=>this.openModal()),this.tabs.forEach(e=>e.addEventListener("click",e=>this.switchTab(e)))}openModal(){this.modalElement.classList.add("is-active");const e=document.querySelector("#algorithm-mode").value;this.displayDetails(e);const t=document.querySelector(`.algorithms-tab[data-algorithm=${e}]`);this.activateTab(t)}closeModal(){this.modalElement.classList.remove("is-active")}activateTab(e){this.tabs.forEach(e=>e.classList.remove("is-active")),e.classList.add("is-active")}displayDetails(e){this.algorithmOverview.innerHTML=this.algorithms[e].overview,this.algorithmSpecifics.innerHTML=this.algorithms[e].specifics,this.algorithmFeatures.innerHTML=this.algorithms[e].features}switchTab(e){let t=e.currentTarget;const i=t.dataset.algorithm;this.activateTab(t),this.displayDetails(i)}}let P,C;const B=window.devicePixelRatio||1;let k,x,L,M,T,E,A,I,S,R,H,O=new l,F=[];let q,X=20,j={force:"<b>Brute Force Algorithm</b>: Checks every possible path, guarantees shortest path",greedy:"<b>Greedy Algorithm</b>: Each node goes to the next closest node, finds suboptimal path excluding trivial cases",hillClimber:"<b>Hill Climber Algorithm</b>: Compares tiny changes to current path, chooses better one",annealing:"<b>Annealing Algorithm</b>: Gradually improves through random changes but avoids local minimums",genetic:"<b>Genetic Algorithm</b>: Simulates all of human life",uncross:"<b>2-Opt Algorithm</b>: Chooses random path, then uncrosses intersections",speedy:"<b>Speedy Algorithm</b>: A custom algorithm that combines greedy, annealing, and 2-opt algorithms",bogo:"<b>Bogo-Style Algorithm</b>: Chooses random path, odds of finding shortest path is 1:(n - 1)!"};function z(e=!1){let t=performance.now();O=e?c.optimize(O,M,P,A,k):c.optimize(O,M,P,A);let i=performance.now();T.innerHTML=(i-t).toFixed(3),O.draw(C,F,R,H,A),E.innerHTML=""+O.length(A).toFixed(0)}function Y(e){return[e.clientX-P.getBoundingClientRect().left,e.clientY-P.getBoundingClientRect().top]}function G(e){if(!(3==e.which||2==e.button)){if(1==A){if(x=V(Y(e)),0==d.isPointInBlock(x,C,B))return}else x=Y(e);let i=(null==t&&(t=x),O.positionInCity(t[0],t[1]));i.length?(k=i[0],k.selected=!0,A&&O.draw(C,F,R,H,A)):function(e){let t,i,n;if(A){t=x[0],i=x[1];let e=t,s=i-H;d.isPointInBlock([t,i-H],C,B)&&(s=i+H);let o=Math.round((t-R/2)/R);const r=o-1-Math.floor(o/4),a=Math.floor(o/4);n=new d(t,i,P,e,s,a,r%3,R)}else t=e.clientX-P.getBoundingClientRect().left-d.radius/2,i=e.clientY-P.getBoundingClientRect().top-d.radius/2,n=new d(t,i,P);O.addCity(n),z()}(e)}var t;L=!0}function W(e){k&&L&&(O.removeCity(k),z()),L=void 0,k&&(k.selected=!1),k=void 0,A&&(q.classList.add("is-hidden"),O.draw(C,F,R,H,A))}function D(e){if(k)if(A){let t=V(Y(e));if((t[0]!=k.xPos||t[1]!=k.yPos)&&d.isPointInBlock(t,C,B)&&0==O.positionInCity(t[0],t[1]).length){let e=t[0],i=t[1]-H;d.isPointInBlock([t[0],t[1]-H],C,B)&&(i=t[1]+H);let n=Math.round((t[0]-R/2)/R);const s=n-1-Math.floor(n/4),o=Math.floor(n/4),r=s%3;k.move(t[0],t[1],e,i,o,r,R),z(!0)}!function(e){q.classList.remove("is-hidden"),q.style.transform=`translate(calc(${e.clientX}px - 50%), calc(${e.clientY}px - 200%)) rotate(-30deg)`}(e)}else{let t=Y(e);k.move(t[0],t[1]),z(!0)}L=!1}function V(e){return function(e){let t=Math.floor(e[0]*R+R/2),i=Math.floor(e[1]*H+H/2);return[t,i]}(function(e){let t=Math.floor(e[0]/R),i=Math.floor(e[1]/H);return[t,i]}(e))}function _(e,t){let i=window.innerWidth,n=window.innerHeight;n-=document.querySelector("#top-navbar").getBoundingClientRect().height,n-=document.querySelector("#bottom-navbar").getBoundingClientRect().height,i*=B,n*=B,function(e,t,i,n){if(O.cities.length){const s=i/e,o=n/t;O.cities.forEach(e=>{e.canvas=P,e.move(Math.round(e.xPos*s),Math.round(e.yPos*o))})}}(e.width,e.height,i,n),e.width=i,e.height=n,C=e.getContext("2d"),C.scale(B,B),0!=t&&z()}function N(){M=document.getElementById("algorithm-mode").value,O.randomizeRoute(),z(),document.querySelector("#algorithm-descriptions").innerHTML=j[M]}function $(e){const t=P.getBoundingClientRect().width,i=P.getBoundingClientRect().height,n=d.radius;if(O.clear(),O.draw(C,F,R,H,A),A){const t=3*S,i=2*I,n=[],s=Math.min(e,t*i);for(;n.length<s;){const e=Math.floor(Math.random()*t),s=Math.floor(Math.random()*i);0==n.filter(t=>t[0]==e&&t[1]==s).length&&n.push([e,s])}n.forEach(e=>{const t=(e[0]+Math.floor(e[0]/3)+1)*R+R/2,i=(e[1]+Math.floor(e[1]/2)+1)*H+H/2;let n=t,s=i-H;d.isPointInBlock([t,i-H],C,B)&&(s=i+H);const o=Math.floor(e[0]/3),r=e[0]%3,a=new d(t,i,P,n,s,o,r,R,H);O.addCity(a)})}else for(let s=0;s<e;s++){const e=new d(Math.floor(Math.random()*(t-2*n))+n,Math.floor(Math.random()*(i-2*n))+n,P);O.addCity(e)}N()}function J(){A?function(){const e=P.getBoundingClientRect().width,t=P.getBoundingClientRect().height;S=Math.floor(e/200),R=e/(4*S+1),I=Math.round(t/(3*R+1)),H=t/(3*I+1);for(let e=0;e<S;e++){let t=4*e+1;for(let e=0;e<I;e++){let i=3*e+1;F.push(new f(t,i,3,2))}}}():F=[]}function U(){O.clear(),z()}function K(e){A=e.currentTarget.checked,X=A?20:200,J(),$(X)}function Q(e){z(!1)}window.addEventListener("load",()=>O.draw(C,F,R,H,A)),window.addEventListener("DOMContentLoaded",(function(){var e;P=document.querySelector("canvas"),T=document.querySelector("#timing"),E=document.querySelector("#length"),q=document.querySelector("#hoveredHouse"),_(e=P,!1),e.addEventListener("mousedown",G),e.addEventListener("mouseup",W),e.addEventListener("mousemove",D),A=document.getElementById("mode").checked,d.houseImage.src="./assets/house.svg",document.getElementById("algorithm-mode").addEventListener("change",N),document.getElementById("clear-board").addEventListener("click",U),document.getElementById("random-board").addEventListener("click",()=>$(X)),document.getElementById("mode").addEventListener("change",K),window.addEventListener("resize",()=>_(P)),document.getElementById("recalculate-button").addEventListener("click",Q),J(),$(X),new v,new w}))}]);